<html>
  <body>
  <style type="text/css">
    canvas {
      border: 2px solid black;
    }
  </style>
  <div>
    <canvas width="600" 
            height="300">
    </canvas>
  </div>
  </body> 
  <script>
    // Global Vars
    var sqmSize = 10

    class Keyboard {
      addKey(obj, keyCode, callback) {
        this.keyCodes[keyCode] = {callback: callback, obj: obj}
      }
      loop(e) { 
        for(let key in this.keyCodes) {
          if(e.keyCode == key) {
            let code = this.keyCodes[key]
            code.callback(code.obj)
          }
        }
      }	
      constructor() {
        this.keyCodes = {}
        document.addEventListener("keydown", (e) => this.loop(e))
      }       
    }

    class Object {
      constructor() { 
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.color = "black";
        this.doingAction = 0;
      }

      setDoingAction(delay) {
        this.doingAction = new Date().getTime() + delay
      }

      isDoingAction() {
        return (this.doingAction < new Date().getTime())
      }

      onCollision(callback) {
        var objects = this.parent.objects
        for(let index in objects) {
          if(this.id != objects[index].id) {
            if((this.x > objects[index].x || this.x + this.w > objects[index].x) &&
            (this.x < objects[index].x + objects[index].w || this.x + this.w < objects[index].x + objects[index].w) &&
            (this.y > objects[index].y || this.y + this.h > objects[index].y) &&
            (this.y < objects[index].y + objects[index].h || this.y + this.h < objects[index].y + objects[index].h)) {      
              callback(this, objects[index])
            }
          }
        }
      }
    }

    class Game {
      constructor() {
        this.canvas = document.getElementsByTagName("canvas")[0];
        this.ctx = this.canvas.getContext("2d");
        this.objects = []
        this.objectNumber = 0
        this.callback = null
        this.requestAnimation = requestAnimationFrame(() => this.loop())
      }   

      content(callback) {
        this.callback = callback
      }

      start() {
        this.callback(this)
      }

      reset() {
        this.objects = []
        this.start()
      }

      loop() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for(let obj of this.objects) {
          this.ctx.fillStyle = obj.color;

          if(obj.text)
            this.ctx.fillText(obj.text, obj.x, obj.y)

          if(obj.w > 0 && obj.h > 0)
            this.ctx.fillRect(obj.x, obj.y, obj.w, obj.h)

          if(obj.onThink !== undefined)
            obj.onThink()
        }	         
        this.requestAnimation = requestAnimationFrame(() => this.loop())
      }

      appendObject(obj) {
        obj.parent = this
        obj.id = this.objectNumber++
        this.objects.push(obj)

        if(obj.onAppend)
          obj.onAppend()
      }
    }

    class Score extends Object {
      constructor(x, y) {
        super()
        this.x = x
        this.y = y
        this.w = this.h = 0
        this.number = 0
        this.refreshScore()
      }

      addScorePoint() {
        this.number++
      }

      refreshScore() {
        this.text = `Score: ${this.number}`
      }
    }

    class Food extends Object {
      constructor(snake, score) {
        super()
        this.snake = snake
        this.score = score
        this.color = "red"
        this.w = this.h = sqmSize
      }

      onAppend() {
        this.setRandomPosition()
      }

      setRandomPosition() {
        this.x = Math.floor(Math.random() * (this.parent.canvas.width / sqmSize)) * sqmSize
        this.y = Math.floor(Math.random() * (this.parent.canvas.height / sqmSize)) * sqmSize
      }

      onThink() {
        this.onCollision((self, collider) => {
          this.score.addScorePoint()
          this.score.refreshScore()
          this.snake.createNode()

          this.setRandomPosition()
        })
      }
    }

    class SnakeNode extends Object {
      constructor() {
        super()
      }
    }

    class Snake extends Object {
      constructor() {
        super()
        this.w = this.h = sqmSize
        this.x = this.y = 100
        this.direction = 1
        this.nodes = []
      }

      onAppend() {
        for(let i = 0; i < 3; i++) {
          this.createNode()
        }
      }

      onThink() {
        if(!this.isDoingAction()) {
          return;
        }

        var lastPosX = this.x
        var lastPosY = this.y

        if(this.direction == 0) {
          this.y -= sqmSize
        } else if(this.direction == 1) {
          this.x += sqmSize
        } else if(this.direction == 2) {
          this.y += sqmSize
        } else if(this.direction == 3) {
          this.x -= sqmSize
        }

        if(this.x < 0 || this.x > this.parent.canvas.width ||
           this.y < 0 || this.y > this.parent.canvas.height) {
          this.parent.reset()
          return;
        }

        for(let node of this.nodes) {
          let tmpPosX = node.x
          let tmpPosY = node.y

          node.x = lastPosX
          node.y = lastPosY

          lastPosX = tmpPosX
          lastPosY = tmpPosY
        }

        this.onCollision((self, collider) => {
          if(collider instanceof SnakeNode) {
            this.parent.reset()
          }
        })

        this.setDoingAction(50)
      }

      get lastNode() {
        return this.nodes[this.nodes.length - 1] || this
      }

      createNode() {
        let obj = new SnakeNode()
            obj.w = obj.h = sqmSize
            obj.direction = this.lastNode.direction

        if(obj.direction == 0) {
          obj.x = this.lastNode.x
          obj.y = this.lastNode.y + this.lastNode.h
        } else if(obj.direction == 1) {
          obj.x = this.lastNode.x - this.lastNode.w
          obj.y = this.lastNode.y
        } else if(obj.direction == 2) {
          obj.x = this.lastNode.x
          obj.y = this.lastNode.y - this.lastNode.w
        } else if(obj.direction == 3) {
          obj.x = this.lastNode.x + this.lastNode.w
          obj.y = this.lastNode.y
        }

        this.nodes.push(obj)
        this.parent.appendObject(obj)
      }

      setDirection(dir) {
        let oppositeDir = ({0: 2, 1: 3, 2: 0, 3: 1})[dir]
        
        this.direction = (this.direction != oppositeDir) ? dir : oppositeDir
      }
    }

    var game = new Game()
    game.content((obj) => {
      var score = new Score(10, 10)
      var snake = new Snake()
      var food = new Food(snake, score)
      var keyboard = new Keyboard()
      
      keyboard.addKey(snake, 38, () => snake.setDirection(0)) // Cima (0)
      keyboard.addKey(snake, 39, () => snake.setDirection(1)) // Direita (1)
      keyboard.addKey(snake, 40, () => snake.setDirection(2)) // Baixo (2)
      keyboard.addKey(snake, 37, () => snake.setDirection(3)) // Esquerda (3)

      obj.appendObject(food)
      obj.appendObject(snake)
      obj.appendObject(score)
    })

    game.start()

  </script>
</html>